 Each conversion specification is introduced by the character %, and ends with a conversion specifier.
 In between there may be (in this order) zero or more flags, an optional minimum field width,
 an optional precision and an optional length modifier.
 % flags, minimum width, precision, lenght modifier

flags and combinations:
-	A negative field width flag; the converted value is to be left adjusted on the field boundary.
	Except for n conversions, the converted value is padded on the right with blanks, rather than
	on the left with blanks or zeros.  A - overrides a 0 if both are given.
0	Zero padding.  For all conversions except n, the converted value is padded on the left with
	zeros rather than blanks.  If a precision is given with a numeric conversion (d, i, o, u, i, x,
	and X), the 0 flag is ignored.

. - precision specifier

*  if specified value is contained in variable

+	A sign must always be placed before a number produced by a signed conversion. A + overrides a
	space if both are used.

minimum field width:
	If the converted value has fewer characters than the field width, it will be padded with spaces on
	the left (or right, if the left-adjustment flag has been given). Instead of a decimal digit string one
	may write "*" or "*m$" (for some decimal integer m) to specify that the field width is given in the
	 next argument, or in the m-th argument, respectively, which must be of type int. A negative field
	width is taken as a '-' flag followed by a positive field width. In no case does a nonexistent or
	small field width cause truncation of a field; if the result of a conversion is wider than the field
	width, the field is expanded to contain the conversion result.If

 precision:
	An optional precision, in the form of a period ('.') followed by an optional decimal digit string.
	Instead of a decimal digit string one may write "*" or "*m$" (for some decimal integer m) to specify
	that the precision is given in the next argument, or in the m-th argument, respectively, which must
	be of type int. If the precision is given as just '.', or the precision is negative, the precision
	is taken to be zero. This gives the minimum number of digits to appear for d, i, o, u, x, and X
	conversions, the number of digits to appear after the radix character for a, A, e, E, f, and F
	conversions, the maximum number of significant digits for g and G conversions, or the maximum
	number of characters to be printed from a string for s and S conversions.

conversions:
c	The int argument is converted to an unsigned char, and the resulting character is written.
s	string  The char * argument is expected to be a pointer to an array of character type
    (pointer to a string).  Characters from the array are written up to (but not including)
	a terminating NUL character; if a precision is specified, no more than the number specified
	are written.  If a precision is given, no null character need be present; if the precision
	is not specified, or is greater than the size of the array, the array must contain a terminating
	NUL character.

length modifier:



p	The void * pointer argument is printed in hexadecimal (as if by `%#x' or `%#lx')
d	signed decimal
i	signed decimal
u	unsigned decimal
x	unsigned hexadimical abcdef used  The precision, if any, gives the minimum number of digits that
	must appear; if the converted value requires fewer digits, it is padded on the left with zeros.
X	unsigned hexadimical capital
%	A `%' is written.  No argument is converted.  The complete conversion specification is `%%'.


RETURN valuef
Bytes printed excluding terminating null byte

1. Count vars
2. Loop through string, print every char if % encountered
	2.1 Trim that part from %totypespecifier
	2.3 Parse string
	2.4 If * encountered, parse value from argument
	2.5 Fill s_var struct
	2.6 Print accordingly
	2.7 continue from step 2
	
